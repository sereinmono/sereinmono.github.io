(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{737:function(n,t,o){var content=o(748);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[n.i,content,""]]),content.locals&&(n.exports=content.locals);(0,o(19).default)("3ef0d950",content,!0,{sourceMap:!1})},747:function(n,t,o){"use strict";o(737)},748:function(n,t,o){var e=o(18)(!1);e.push([n.i,"h1{font-size:3.75rem}h1,h2{font-weight:300;padding-top:16}h2{font-size:3rem}h3{font-size:2.125rem}h3,h4{font-weight:400;padding-top:16}h4{font-size:1.5rem}h5{font-weight:500;font-size:1.25rem}h5,h6{padding-top:16}h6{font-weight:400;font-size:1rem}p{font-size:1.25rem;font-weight:300;padding-top:16}blockquote{padding-left:30px}.my-code{background-color:transparent}",""]),n.exports=e},766:function(n,t,o){"use strict";o.r(t);var e={name:"IndexPage",computed:{md:function(){return'<section><h1>AC Activator 开发记录</h1>\n<h2>写在前面</h2>\n<p>在上一篇文章中，我实现了能够存储设置、修改设置、承载设置内容的类 <code>Settings</code> 和 <code>SettingInfo</code>。并且，我设计并实现了一个『设置』页面，允许用户通过 GUI 的方式来便捷地修改 KMS 操作设置，且提到了『 User Is Drunk 』的设计理念。接下来，就即将要实现 AC Activator 最为核心的功能——实现激活。</p>\n<h2>激活的原理</h2>\n<p>在第一篇文章中，我谈到了要激活需要执行三条命令：</p>\n<pre><code>\nslmgr /ipk &lt;product key&gt;\nslmgr /skms &lt;kms server&gt;\nslmgr /ato\n</code></pre>\n<p>三条命令，缺一不可。而我们想要实现的事情也很简单，就是要使用这个 GUI 程序，帮助用户代为执行这三条命令。然而，我们就面临了一个问题：我们固然可以通过创建子进程的方式来实现对于命令的执行，但是『管理员权限』从哪里来？</p>\n<p>调整 app.manifest 文件，将</p>\n<pre><code class="language-xaml">\n&lt;requestedExecutionLevel  level=&quot;asInvoker&quot; uiAccess=&quot;false&quot; /&gt;\n</code></pre>\n<p>改为：</p>\n<pre><code class="language-xaml">\n&lt;requestedExecutionLevel  level=&quot;requireAdministrator&quot; uiAccess=&quot;false&quot; /&gt;\n</code></pre>\n<p><strong>然后，你就会惊讶地发现，这个应用直接『暴毙』了：无法调试、无法运行</strong>。</p>\n<p>这个时候，我们会发现这条路根本走不通（我目前也没有搞明白到底是什么状况），现在我们将 app.manifest 修改回原来的模样。</p>\n<p>此时我们就需要搬出 PowerShell 了。PowerShell 可以通过 <code>start-process</code> 命令实现通过 UAC 申请提升权限。</p>\n<pre><code>\npowershell start-process &lt;命令&gt; -verb runAs\n</code></pre>\n<p>所以，初步方法：</p>\n<ol>\n<li>首先，由程序来创建一个 activate.bat</li>\n<li>然后，由程序创建一个 PowerShell 子进程来执行 activate.bat</li>\n<li>结束激活</li>\n</ol>\n<p>然而，这又会涉及到一个问题：我们在执行激活时，会突然蹦出一个黑乎乎的命令提示符糊你脸上——在这种情况下，你到底执行了什么命令，在用户的视角来说全部都一览无余。另外一方面，『弹出另外的窗口』本身就会增加用户不必要的担忧。在设计应用时，我们追求的是一个『黑箱』：你输入命令并输出结果，并且你不知道黑箱内部发生了什么，表现在开发上来讲，就是不将非必要的信息透露给用户，只提供给用户以结果。你并不想要在日常使用浏览器的时候紧盯着 Console 或是 Network / Source 窗口，相信我，你不会喜欢这样的体验的。</p>\n<p>所以，为了隐藏窗口，我们需要依赖于 VBScript。</p>\n<pre><code class="language-vbscript">\n<span class="hljs-keyword">Set</span> ws = <span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;WScript.shell&quot;</span>)\nws.Run <span class="hljs-string">&quot;cmd start /c {activate.bat绝对路径}&quot;</span>, <span class="hljs-number">0</span>\n</code></pre>\n<p>通过这种方式，我们就可以实现批处理文件在执行时的窗口隐藏。</p>\n<p>所以，我们将这个过程调整为：</p>\n<ol>\n<li>首先，由程序来创建一个 activate.bat</li>\n<li>然后，创建一个执行 activate.bat 的 launcher.vbs</li>\n<li>通过 PowerShell 子进程执行 launcher.vbs</li>\n<li>结束激活</li>\n</ol>\n<h2><code>Activator</code> 的实现</h2>\n<p>同 <code>Settings</code> 类，我们也将激活的功能单独地分散在一个专门的类中。按照这个过程，我们来实现 Activator.cs 的代码如下：</p>\n<pre><code class="language-c#">\n<span class="hljs-keyword">using</span> System;\n<span class="hljs-keyword">using</span> System.Collections.Generic;\n<span class="hljs-keyword">using</span> System.Diagnostics;\n<span class="hljs-keyword">using</span> System.IO;\n<span class="hljs-keyword">using</span> System.Linq;\n<span class="hljs-keyword">using</span> System.Text;\n<span class="hljs-keyword">using</span> System.Threading.Tasks;\n\n\n<span class="hljs-keyword">namespace</span> <span class="hljs-title">ACActivator</span>\n{\n    \n    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>\n    <span class="hljs-comment"><span class="hljs-doctag">///</span> 这个应用的『心脏』与『灵魂』：激活器。</span>\n    <span class="hljs-comment"><span class="hljs-doctag">///</span> 根据应用中提供的KMS Url生成两个文件：『launcher.vbs』和『activate.bat』。</span>\n    <span class="hljs-comment"><span class="hljs-doctag">///</span> 『launcher.vbs』能够实现在不生成新窗口的情况下运行『activate.bat』。</span>\n    <span class="hljs-comment"><span class="hljs-doctag">///</span> 『activate.bat』通过Windows提供的『slmgr.vbs』完成激活。</span>\n    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>\n\n    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Activator</span>\n    {\n\n        <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> _localFolderPath = Windows.Storage.ApplicationData.Current.LocalFolder.Path;\n\n        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Activate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> KMSUrl</span>)</span>\n        {\n            <span class="hljs-built_in">string</span> batFilePath = Path.Combine(_localFolderPath, <span class="hljs-string">&quot;activate.bat&quot;</span>);\n            <span class="hljs-built_in">string</span> vbsFilePath = Path.Combine(_localFolderPath, <span class="hljs-string">&quot;launcher.vbs&quot;</span>);\n            File.WriteAllText(batFilePath, <span class="hljs-string">$&quot;slmgr /skms <span class="hljs-subst">{KMSUrl}</span> &amp;&amp; slmgr /ato&quot;</span>);\n            File.WriteAllText(vbsFilePath, <span class="hljs-string">$&quot;Set ws = CreateObject(\\&quot;WScript.shell\\&quot;)\\nws.Run \\&quot;cmd start /c <span class="hljs-subst">{batFilePath}</span>\\&quot;,0&quot;</span>);\n            RunActivate();\n        }\n\n        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RunActivate</span>(<span class="hljs-params"></span>)</span>\n        {            \n            <span class="hljs-built_in">string</span> vbsp = Path.Combine(_localFolderPath, <span class="hljs-string">&quot;launcher.vbs&quot;</span>);\n            Process process = <span class="hljs-keyword">new</span>();\n            process.StartInfo.FileName = <span class="hljs-string">&quot;powershell.exe&quot;</span>;\n            process.StartInfo.Arguments = <span class="hljs-string">$&quot;start-process wscript <span class="hljs-subst">{vbsp}</span> –verb runAs&quot;</span>;\n            process.StartInfo.UseShellExecute = <span class="hljs-literal">false</span>;\n            process.StartInfo.CreateNoWindow = <span class="hljs-literal">true</span>;\n            process.Start();\n            process.WaitForExit();\n            process.Close();\n        }\n    }\n}\n</code></pre>\n<p>在 Activator.cs 中定义了一个静态类 <code>Activator</code>，这个类用来实现激活的功能。外部程序调用 <code>Activate()</code> 来执行激活。在函数 <code>Activate()</code> 中，我们创建 activate.bat 和 launcher.vbs。然后，运行 <code>RunActivate()</code>，创建一个 PowerShell 的子进程来执行 launcher.vbs。在这之中将 <code>process.StartInfo.UseShellExcute</code> 禁用，是因为已经确切了我们要运行什么程序，且清楚运行的是一个程序。将 <code>process.StartInfo.CreateNoWindow</code> 禁用。是因为我们不想要 PowerShell 创建它的窗口——刚才我们已经提到要对用户塑造一个『黑箱』。</p>\n<h2>主页</h2>\n<p>接下来我们将 <code>ActionPage</code> 的相关功能对接上去。以下是 ActionPage.xaml 以及 ActionPage.xaml.cs 的完整代码：</p>\n<pre><code class="language-xaml">\n&lt;Page\n    x:Class=&quot;ACActivator.ActionPage&quot;\n    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;\n    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;\n    xmlns:local=&quot;using:ACActivator&quot;\n    xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;\n    xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;\n    mc:Ignorable=&quot;d&quot;\n    Background=&quot;{ThemeResource ApplicationPageBackgroundThemeBrush}&quot;&gt;\n\n    &lt;Grid Background=&quot;{StaticResource acBackgroundBrush}&quot;&gt;\n        &lt;StackPanel Margin=&quot;55,20,20,0&quot; Background=&quot;{StaticResource acBackgroundBrush}&quot;&gt;\n\n            &lt;!--一些提示。--&gt;\n\n            &lt;InfoBar\n                IsOpen=&quot;True&quot;\n                IsClosable=&quot;True&quot;\n                Title=&quot;危险行为&quot;\n                Message=&quot;您即将进行的操作涉及到更改该Windows操作系统副本的KMS设置和激活设置。请充分考虑并了解继续操作所涉及到的风险。权限越高，责任越大。&quot;\n                Severity=&quot;Warning&quot;&gt;\n                &lt;InfoBar.IconSource&gt;\n                    &lt;SymbolIconSource Symbol=&quot;Setting&quot; /&gt;\n                &lt;/InfoBar.IconSource&gt;\n            &lt;/InfoBar&gt;\n            \n            &lt;InfoBar\n                IsOpen=&quot;True&quot;\n                IsClosable=&quot;True&quot;\n                Title=&quot;法律风险提示&quot;\n                Margin=&quot;0, 5&quot;\n                Message=&quot;经过KMS激活后，您可能会成为盗版Windows操作系统的受害者。本程序只是一个带有GUI的KMS操作工具，并不倡导激活盗版操作系统。请不要输入未经Microsoft授权的KMS服务器，否则您将得到一个盗版操作系统。根据您所在地区的法律法规，这可能将使你面临法律风险。出于道德和法律层面考虑，我们建议您支持正版。&quot;\n                Closed=&quot;InfoBar_Closed&quot;/&gt;\n\n            &lt;InfoBar\n                IsOpen=&quot;True&quot;\n                IsClosable=&quot;True&quot;\n                Title=&quot;支持我们！&quot;\n                Margin=&quot;0, 1&quot;\n                Message=&quot;本程序使用热爱作为核心技术。访问托管于Github的项目来给本作品Star。当然，如果发现问题，疑难杂症也可以在这里解决。&quot;\n                Severity=&quot;Error&quot;\n                Closed=&quot;InfoBar_Closed&quot;&gt;\n                &lt;InfoBar.IconSource&gt;\n                    &lt;FontIconSource Glyph=&quot;&amp;#xEB52;&quot; Foreground=&quot;DarkRed&quot;/&gt;\n                &lt;/InfoBar.IconSource&gt;\n                &lt;InfoBar.ActionButton&gt;\n                    &lt;HyperlinkButton \n                        Content=&quot;看一眼我们的仓库&quot;\n                        NavigateUri=&quot;https://github.com/sereinmono/ACActivator&quot;\n                        Foreground=&quot;DarkRed&quot;/&gt;\n                &lt;/InfoBar.ActionButton&gt;\n            &lt;/InfoBar&gt;\n\n        &lt;/StackPanel&gt;\n        \n        &lt;Button \n            Margin=&quot;0, 0, 20, 20&quot; \n            Style=&quot;{StaticResource AccentButtonStyle}&quot; \n            HorizontalAlignment=&quot;Right&quot; \n            VerticalAlignment=&quot;Bottom&quot; \n            Width=&quot;50&quot; \n            Height=&quot;50&quot; \n            x:Name=&quot;ActionButton&quot;&gt;\n            &lt;!--激活按钮--&gt;\n            &lt;FontIcon FontFamily=&quot;{StaticResource SymbolThemeFontFamily}&quot; Glyph=&quot;&amp;#xe945;&quot;/&gt;\n            &lt;Button.Flyout&gt;\n                &lt;!--提醒用户：注意KMS地址--&gt;\n                &lt;Flyout&gt;\n                    &lt;StackPanel&gt;\n                        &lt;TextBlock Style=&quot;{ThemeResource BaseTextBlockStyle}&quot; Text=&quot;{x:Bind noticeText}&quot; Margin=&quot;0,0,0,12&quot; x:Name=&quot;ButtonFlyoutText&quot;/&gt;\n                        &lt;Button Content=&quot;明白，继续&quot; Click=&quot;Button_Click&quot;/&gt;\n                    &lt;/StackPanel&gt;\n                &lt;/Flyout&gt;\n            &lt;/Button.Flyout&gt;\n            &lt;Button.Resources&gt;\n                &lt;!--教程提示--&gt;\n                &lt;TeachingTip x:Name=&quot;HowToStartTip&quot;\n                    Target=&quot;{x:Bind ActionButton}&quot;\n                    Title=&quot;立即开始&quot;\n                    Subtitle=&quot;只需点击这里然后就可以开始了。&quot;\n                    IsOpen=&quot;False&quot;/&gt;\n            &lt;/Button.Resources&gt;\n        &lt;/Button&gt;\n        \n    &lt;/Grid&gt;\n    \n&lt;/Page&gt;\n</code></pre>\n<pre><code class="language-c#">\n<span class="hljs-keyword">using</span> Microsoft.UI.Xaml;\n<span class="hljs-keyword">using</span> Microsoft.UI.Xaml.Controls;\n<span class="hljs-keyword">using</span> Microsoft.UI.Xaml.Controls.Primitives;\n<span class="hljs-keyword">using</span> Microsoft.UI.Xaml.Data;\n<span class="hljs-keyword">using</span> Microsoft.UI.Xaml.Input;\n<span class="hljs-keyword">using</span> Microsoft.UI.Xaml.Media;\n<span class="hljs-keyword">using</span> Microsoft.UI.Xaml.Navigation;\n<span class="hljs-keyword">using</span> System;\n<span class="hljs-keyword">using</span> System.Collections.Generic;\n<span class="hljs-keyword">using</span> System.Diagnostics;\n<span class="hljs-keyword">using</span> System.IO;\n<span class="hljs-keyword">using</span> System.Linq;\n<span class="hljs-keyword">using</span> System.Runtime.InteropServices.WindowsRuntime;\n<span class="hljs-keyword">using</span> Windows.Foundation;\n<span class="hljs-keyword">using</span> Windows.Foundation.Collections;\n\n\n<span class="hljs-keyword">namespace</span> <span class="hljs-title">ACActivator</span>\n{\n    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>\n    <span class="hljs-comment"><span class="hljs-doctag">///</span> 这是一个操作页，允许用户开始操作，并显示警告和提示等。</span>\n    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>\n\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ActionPage</span> : <span class="hljs-title">Page</span>\n    {\n        <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> noticeText;\n\n        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ActionPage</span>(<span class="hljs-params"></span>)</span>\n        {\n            <span class="hljs-comment">// 在这个方法中，会初始化让用户注意一下KMS Server地址的『noticeText』，并向用户显示指引提示『HowToStartTip』。</span>\n            \n            noticeText = <span class="hljs-string">$&quot;您即将更改Windows激活设置。\\n你使用的KMS服务器为：<span class="hljs-subst">{Settings.ReadSettings().KMSUrl}</span>&quot;</span>;\n            <span class="hljs-keyword">this</span>.InitializeComponent();\n            <span class="hljs-built_in">bool</span> haveTaughtHowToStart = Settings.ReadSettings().haveTaughtHowToStart;\n            <span class="hljs-keyword">if</span> (!haveTaughtHowToStart)\n            {\n                HowToStartTip.IsOpen = <span class="hljs-literal">true</span>;\n                SettingsInfo newInfo = Settings.ReadSettings();\n                newInfo.haveTaughtHowToStart = <span class="hljs-literal">true</span>;\n                Settings.WriteSettings(newInfo);\n            }\n        }\n\n        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Button_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, RoutedEventArgs e</span>)</span>\n        {\n            <span class="hljs-comment">// 激活按钮按完之后要干两件事情：『激活』、『提醒用户已经激活』</span>\n            \n            Activator.Activate(Settings.ReadSettings().KMSUrl);\n            ShowDialog();\n        }\n\n        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowDialog</span>(<span class="hljs-params"></span>)</span>\n        {\n            <span class="hljs-comment">// 显示一个提示激活即将完成的弹窗。</span>\n\n            ContentDialog dialog = <span class="hljs-keyword">new</span>()\n            {\n                Title = <span class="hljs-string">&quot;激活即将完成。&quot;</span>,\n                CloseButtonText = <span class="hljs-string">&quot;好的，谢谢&quot;</span>,\n                Content = <span class="hljs-string">&quot;山随平野尽，江入大荒流。\\n您可以关闭乃至于卸载该程序。&quot;</span>,\n                FullSizeDesired = <span class="hljs-literal">false</span>,\n                <span class="hljs-comment">// 注意：请不要将此行删去！详细说明请见：https://github.com/microsoft/microsoft-ui-xaml/issues/2504</span>\n                XamlRoot = <span class="hljs-keyword">this</span>.Content.XamlRoot\n            };\n\n            <span class="hljs-keyword">await</span> dialog.ShowAsync();\n        }\n\n    }\n}\n</code></pre>\n<p>至此，这个程序的主要功能就已经实现完毕了。现在当我们运行这个程序的时候，我们可以十分『流畅』地点击右下角的激活按钮，确认 KMS 服务器地址，赋予管理员权限，看到一个『完成激活』的弹窗。有了这个程序的帮助，我们可以在远离命令提示符的情况下『流畅而优雅』地完成这一切。</p>\n<p>不过，最后还有一点点要润『色』的地方。</p>\n<h2>实现深色模式</h2>\n<pre><code class="language-xaml">\n&lt;ResourceDictionary.ThemeDictionaries&gt;\n    &lt;ResourceDictionary x:Key=&quot;Light&quot;&gt;\n        &lt;SolidColorBrush x:Key=&quot;acBackgroundBrush&quot; Color=&quot;White&quot;/&gt;\n    &lt;/ResourceDictionary&gt;\n    &lt;ResourceDictionary x:Key=&quot;Dark&quot;&gt;\n        &lt;SolidColorBrush x:Key=&quot;acBackgroundBrush&quot; Color=&quot;#111111&quot;/&gt;\n    &lt;/ResourceDictionary&gt;\n&lt;/ResourceDictionary.ThemeDictionaries&gt;\n</code></pre>\n<p>通过定义 <code>acBackgroundBrush</code>，我们实现了对于应用背景的神色模式适配。之后，在 SettingPage.xaml 与 ActionPage.xaml 中，我们将 <code>BackgroundColor</code> 设定为 <code>{StaticResource acBackgroundBrush}</code>即可。</p>\n<h2>最后</h2>\n<p>最后，我成功实现了一个面向于小白的 KMS 激活工具—— AC Activator。<a href="https://github.com/sereinmono/ACActivator/">它的 GitHub 仓库在此处</a>。支持的朋友可以来个 Star。该项目会不断完善。WinUI 3 还有一些让人用起来感觉很离谱的地方，例如不支持真正的亚克力效果和云母，标题栏自定义复杂程度令人发指等等。希望使用 WinUI 3 开发新项目的朋友还可以再等一等，再观望观望。</p>\n</section>\n'}}},l=(o(747),o(65)),c=o(66),r=o.n(c),h=o(724),component=Object(l.a)(e,(function(){var n=this,t=n.$createElement,o=n._self._c||t;return o("v-container",[o("div",{staticClass:"pt-16"}),n._v(" "),o("div",{staticClass:"pt-16"}),n._v(" "),o("div",{staticClass:"pt-16"}),n._v(" "),o("p",{staticClass:"font-weight-thin text-h5"},[n._v("2022.05.10")]),n._v(" "),o("div",{domProps:{innerHTML:n._s(n.md)}})])}),[],!1,null,null,null);t.default=component.exports;r()(component,{VContainer:h.a})}}]);